import {Hash, KeyStore, PublicKey} from "./key-store";

/**
 * DecodedPacket defines the structure of unvalidated and non-decrypted packet.
 * When a packet (buffer) decoded, the function simply returns a DecodedPacket instance.
 * This instance is not safe to use without validating it.
 */
export interface DecodedPacket<C extends Content = Content> {
    rawContent: Buffer;
    signer: PublicKey;
    signature: Buffer;
    isDecoded: true;
    content: C;
}

/**
 * ValidatedPacket defines the structure of validated but non-decrypted yet packet.
 * When a DecodedPacket gets validated, the function simply returns a ValidatedPacket instance.
 * This instance DOESN'T contains decrypted payload.
 */
export interface ValidatedPacket<C extends Content = Content> extends DecodedPacket<C> {
    isValidated: true;
}

/**
 * DecryptedPacket defines the structure of finally validated and decrypted packet.
 * When a ValidatedPacket gets decrypted, the function simply returns a DecryptedPacket instance.
 * 'decryptedPayload' property can be safely used.
 */
export interface DecryptedPacket<C extends Content = Content> extends ValidatedPacket<C> {
    isDecrypted: true;
    decryptedPayload: Buffer;
}

export enum DeliveryType {
    /**
     * PlainBroadcast packet is simplest packet. It has no encryption nor specific target.
     */
    PlainBroadcast = 'plain-broadcast',
    /**
     * EncryptedBroadcast packet is a packet which has encrypted-payload and a pre-shared secret key.
     */
    EncryptedBroadcast = 'encrypted-broadcast',
    /**
     * Private packet targets only a specific receiver. The payload is encrypted with a secret-key which
     *  is generated by ECDH algorithm using signer's and receiver's ec-keys.
     */
    Private = 'private'
}

export interface BaseContent {
    type: DeliveryType;
    payload: Buffer;
    keyHash?: Hash;
    target?: PublicKey;
}

export interface PlainBroadcastContent extends BaseContent {
    type: DeliveryType.PlainBroadcast;
}

export interface EncryptedBroadcastContent extends BaseContent {
    type: DeliveryType.EncryptedBroadcast;
    keyHash: Hash;
}

export interface PrivateContent extends BaseContent {
    type: DeliveryType.Private;
    target: PublicKey;
}

export type Content = PlainBroadcastContent | EncryptedBroadcastContent | PrivateContent;

/**
 * SecondLayer instance provides a secure communication layer on top of any other network protocol.
 * It uses AES-256 and EC-256 cryptography algorithms between nodes.
 * There are 3 communication mode which they can be used in parallel:
 * PlainBroadcast, EncryptedBroadcast, Private
 */
export interface SecondLayer {
    /**
     * SecondLayer instance needs a KeyStore to request for the keys which they are required by
     *  signer, verifier, cipher and decipher algorithms
     * @returns KeyStore instance
     */
    getKeyStore(): KeyStore;

    /**
     * @param raw Raw Buffer of the packet
     * @returns DecodedPacket instance which created by parsing the raw-packet
     */
    decodePacket(raw: Buffer): Promise<DecodedPacket>;
    /**
     * Validates that the signature and signer is related
     * @param decodedPacket DecodedPacket instance to validate if its signature is OK
     * @returns ValidatedPacket instance
     */
    validatePacket<C extends Content>(decodedPacket: DecodedPacket<C>): Promise<ValidatedPacket<C>>;
    /**
     * Decrypts validated packet's encrypted-payload. Required private/secret keys
     *  must be registered in the keystore before.
     * @param validatedPacket ValidatedPacket instance to decrypt its encrypted payload
     * @returns ValidatedPacket instance
     */
    decryptPacket<C extends Content>(validatedPacket: ValidatedPacket<C>): Promise<DecryptedPacket<C>>;

    /**
     * Encodes PlainBroadcast packet which contains plain payload and signature
     * @param plainPayload Payload data to sign and include in packet
     * @param signer PublicKey which is related to a PrivateKey to be used for signing the packet
     * @param type Type MUST be DeliveryType.PlainBroadcast
     */
    encodePacket(plainPayload: Buffer, signer: PublicKey, type: DeliveryType.PlainBroadcast): Promise<Buffer>;
    /**
     * Encodes EncryptedBroadcast packet which contains encrypted payload and signature
     * @param plainPayload Payload data to sign, ENCRYPT and include in packet
     * @param signer PublicKey which is related to a PrivateKey to be used for signing the packet
     * @param type Type MUST be DeliveryType.EncryptedBroadcast
     * @param keyHash Hash of the desired secret-key which is used while encrypting the payload
     */
    encodePacket(plainPayload: Buffer, signer: PublicKey, type: DeliveryType.EncryptedBroadcast, keyHash: Hash): Promise<Buffer>;
    /**
     * Encodes Private packet which contains encrypted payload and signature
     * @param plainPayload Payload data to sign, ENCRYPT and include in packet
     * @param signer PublicKey which is related to a PrivateKey to be used for signing and encrypting the packet
     * @param type Type MUST be DeliveryType.Private
     * @param target PublicKey of the specific target
     */
    encodePacket(plainPayload: Buffer, signer: PublicKey, type: DeliveryType.Private, target: PublicKey): Promise<Buffer>;
}
